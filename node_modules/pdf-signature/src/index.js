"use strict";
exports.__esModule = true;
var fs = require("fs");
var path = require("path");
var PDFToHTML = require("pdftohtmljs");
var pdf = require("html-pdf");
var signaturePDF = /** @class */ (function () {
    function signaturePDF() {
    }
    signaturePDF.prototype.htmlSignature = function (htmlPath, htmlString, x, y, signature, download, documentName, docType) {
        /*
        * @htmlPath string - for static path
        * @htmlString string - html in string format
        * @x number - x coordinate from page
        * @y number - y coordinate from page
        * @signature string - image in base64
        * @download boolean - if is true download the html document (signed) if false return the html string format (signed)
        * @documentName - name your signed document
        * @docType string - document type (html or pdf)
         */
        /*
        * How works?
        * You pass as a parameters the HTML stringify docs and then you check the last element
        * from this string and push new div in the bottom of the page, and in this div element you
        * need add a new signature if if the base64 encoded image. This image is the parameter
        * of the function and then you decode this and put in the variable signature,
        * and then return the HTML string which is signed.
         */
        if (!htmlPath && typeof htmlPath === 'undefined'
            || !signature && typeof signature === 'undefined'
            || !htmlString && typeof htmlString === 'undefined'
            || !x && typeof x === 'undefined'
            || !y && typeof y === 'undefined'
            || !docType && typeof docType === 'undefined') {
            throw new Error('Please pass the parameters at htmlSignature()');
        }
        if (htmlPath && htmlString)
            throw new Error('First or second parameters it should be false');
        var searchEndOfDOM = htmlString.search("</body>");
        if (htmlString) {
            if (!signature && typeof signature === 'undefined')
                throw new Error('Please add the signature');
            htmlPath = undefined;
            if (searchEndOfDOM !== -1) {
                var stampSignaturePosition = "<div style=\"position: absolute; left: " + x + "px; top: " + y + "px;\"> <img src=\"" + signature + "\" alt=\"signature\"/> </div> ";
                var content = htmlString.substr(0, searchEndOfDOM) + stampSignaturePosition + htmlString.substr(searchEndOfDOM);
                if (download && documentName) {
                    var searchHTMLExtension = documentName.search(".html");
                    if (searchHTMLExtension === -1)
                        documentName = documentName + '.html';
                    fs.appendFile(documentName, content, function (error) {
                        if (error)
                            throw new Error(error);
                        console.log('Saved!');
                    });
                }
            }
        }
        if (htmlPath && signature) {
            // Parse HTML document and add signature
            // Make correct path
            var allChar = /(.*)/, htmlExtension = /(.*).html/, checkIfExitExtension = htmlPath.match(htmlExtension), notCorrectPath = htmlPath.match(allChar);
            if (notCorrectPath || checkIfExitExtension) {
                htmlPath = "/" + htmlPath + ".html";
                htmlPath = htmlPath.replace(".html", "");
            }
            var readContent = function (callback) {
                fs.readFile(path.dirname(require.main.filename) + htmlPath, 'utf8', function (error, htmlPath) {
                    if (error)
                        return callback(error);
                    var searchEndOfDOM = htmlPath.search("</body>"), HTMLToString = htmlPath.toString();
                    if (searchEndOfDOM !== -1) {
                        var stampSignaturePosition = "<div style=\"position: absolute; left: " + x + "px; top: " + y + "px;\"> <img src=\"" + signature + "\" alt=\"signature\"/> </div> ";
                        callback(null, HTMLToString.substr(0, searchEndOfDOM) + stampSignaturePosition + HTMLToString.substr(searchEndOfDOM));
                    }
                });
            };
            readContent(function (error, content) {
                if (download && documentName) {
                    var searchHTMLExtension = documentName.search(".html");
                    if (searchHTMLExtension === -1)
                        documentName = documentName + '.html';
                    fs.appendFile(documentName, content, function (error) {
                        if (error)
                            throw new Error(error);
                        console.log('Saved!');
                        if (docType === 'pdf' || docType === 'PDF') {
                            var html = fs.readFileSync(path.dirname(require.main.filename) + ("/" + documentName), 'utf8'), width = 1123, height = 793, options = {
                                width: width + "px",
                                height: height + "px",
                                border: '0px',
                                viewportSize: {
                                    width: width,
                                    height: height
                                }
                            };
                            var pdfDocName = documentName.replace(".html", ".pdf"), outputPath_1 = 'output.html';
                            pdf.create(html, options).toFile(pdfDocName, function (err, res) {
                                if (err)
                                    throw new Error(err);
                                fs.unlink(path.dirname(require.main.filename) + ("/" + outputPath_1), function (error) {
                                    if (error)
                                        return;
                                });
                                fs.unlink(path.dirname(require.main.filename) + ("/" + documentName), function (error) {
                                    if (error)
                                        return;
                                });
                                return res;
                            });
                        }
                    });
                }
            });
        }
        return true;
    };
    signaturePDF.prototype.pdfSignature = function (pdfPath, x, y, signature, download, documentName) {
        /*
            * @pdfPath string - for static path
            * @x number - x coordinate from page
            * @y number - y coordinate from page
            * @signature string - image in base64
            * @download boolean - if is true download the html document (signed) if false return the html string format (signed)
            * @documentName string - name your signed document
         */
        var self = this;
        if (!pdfPath && typeof pdfPath === 'undefined'
            || !signature && typeof signature === 'undefined'
            || !x && typeof x === 'undefined'
            || !y && typeof y === 'undefined') {
            throw new Error('Please pass the html parameters at htmlSignature()');
        }
        if (pdfPath && signature) {
            // Parse HTML document and add signature
            // Make correct path
            var allChar = /(.*)/, htmlExtension = /(.*).pdf/, checkIfExitExtension = pdfPath.match(htmlExtension), notCorrectPath = pdfPath.match(allChar);
            if (notCorrectPath || checkIfExitExtension) {
                pdfPath = "/" + pdfPath + ".pdf";
                pdfPath = pdfPath.replace(".pdf", ".pdf");
            }
            var converter = new PDFToHTML(path.dirname(require.main.filename) + pdfPath, "/output.html");
            // convert the HTML document to PDF
            converter.convert('default').then(function () {
                self.htmlSignature("/output.html", '', x, y, signature, download, documentName, 'pdf');
            })["catch"](function (err) {
                throw new Error("Conversion error: " + err);
            });
        }
    };
    return signaturePDF;
}());
module.exports = signaturePDF;
